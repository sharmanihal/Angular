### **`ngDoCheck()` in Angular**
The `ngDoCheck()` lifecycle hook is used for **custom change detection** in Angular. It runs **after every change detection cycle** and allows you to detect and respond to changes that Angular‚Äôs default change detection might not catch.

---

### **When to Use `ngDoCheck()`?**
1. **Detecting Mutations in Objects or Arrays Passed via `@Input()`**
   - Angular **only detects changes when a new reference is assigned**.
   - If you **mutate** an object or array (instead of replacing it), `ngOnChanges()` **won't trigger**, but `ngDoCheck()` will.

   ```typescript
   @Component({
     selector: 'app-child',
     template: `<p>{{ data | json }}</p>`
   })
   export class ChildComponent implements OnChanges, DoCheck {
     @Input() data: any;

     ngOnChanges(changes: SimpleChanges) {
       console.log('ngOnChanges:', changes);
     }

     ngDoCheck() {
       console.log('ngDoCheck - Runs every change detection cycle');
     }
   }
   ```

   ```typescript
   // In Parent Component
   this.data.push('new value'); // This MUTATES the array; ngOnChanges WON‚ÄôT detect it.
   ```

---

2. **Tracking Performance-Intensive Operations**
   - If you have performance-sensitive logic that you **don‚Äôt want to run on every change detection cycle**, use `ngDoCheck()` with a **manual condition**.

   ```typescript
   ngDoCheck() {
     if (this.someExpensiveCheckNeeded) {
       console.log('Performing expensive operation');
     }
   }
   ```

---

3. **Using `KeyValueDiffers` or `IterableDiffers`**
   - These utilities help **detect changes inside objects or arrays** without replacing them.

   ```typescript
   constructor(private differs: KeyValueDiffers) {
     this.differ = this.differs.find({}).create();
   }

   ngDoCheck() {
     const changes = this.differ.diff(this.data);
     if (changes) {
       console.log('Detected changes in data:', changes);
     }
   }
   ```

---

### **`ngDoCheck()` vs `ngOnChanges()`**
| Feature | `ngOnChanges` | `ngDoCheck` |
|---------|--------------|-------------|
| Runs when `@Input()` changes? | ‚úÖ Yes | ‚úÖ Yes |
| Runs when `@Input()` is mutated? | ‚ùå No | ‚úÖ Yes |
| Runs on every change detection cycle? | ‚ùå No | ‚úÖ Yes |
| Used for detecting deep object/array changes? | ‚ùå No | ‚úÖ Yes |

---

### **When Should You Avoid `ngDoCheck()`?**
‚ö†Ô∏è **Use it cautiously** because it runs **on every change detection cycle**, which can affect performance.  
‚úÖ Instead, try:
- **Using `OnPush` change detection** to optimize performance.
- **Replacing objects/arrays instead of mutating them** so `ngOnChanges()` works.

---

### **Conclusion**
- `ngDoCheck()` is useful when Angular‚Äôs default change detection **misses deep changes** (e.g., mutated arrays/objects).
- It **runs after every change detection cycle**, so **use it wisely** to avoid performance issues.
- Prefer `ngOnChanges()` whenever possible, but if mutations need to be detected, `ngDoCheck()` is your solution! üöÄ
